using Mutagen.Bethesda;
using Mutagen.Bethesda.Oblivion;
using Mutagen.Bethesda.Plugins.Exceptions;
using Mutagen.Bethesda.Synthesis;
using Noggog;

namespace HealthAndDamageScalingPatcher
{
    public class Program
    {
        private static Lazy<Settings> _settings = null!;
        private static Settings Settings => _settings.Value;

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<IOblivionMod, IOblivionModGetter>(RunPatch)
                .SetAutogeneratedSettings("Settings", "settings.json", out _settings)
                .SetTypicalOpen(GameRelease.Oblivion, "YourPatcher.esp")
                .Run(args);
        }

        public static void RunPatch(IPatcherState<IOblivionMod, IOblivionModGetter> state)
        {
            Console.WriteLine("\n\nInitialization successful, beginning patcher process...\n");
            var count = 0;
            // NPCs
            foreach (var oldNpc in state.LoadOrder.PriorityOrder.WinningOverrides<INpcGetter>())
            {
                try
                {
                    if (oldNpc.Stats?.Health == null || oldNpc.EditorID == null)
                        continue;

                    var newNpc = oldNpc.DeepCopy();

                    if (newNpc.Stats?.Health == null || newNpc.Stats.Health <= 1)
                        continue;

                    newNpc.Stats.Health = CalcHealth(newNpc.Stats.Health);

                    state.PatchMod.Npcs.Set(newNpc);
                    Console.WriteLine($"Successfully modified npc. EditorID:{newNpc.EditorID} Name:{newNpc.Name}");
                    ++count;
                    Console.WriteLine($"\tOldHealth:{oldNpc.Stats.Health} NewHealth:{newNpc.Stats.Health}\n");
                }
                catch (Exception ex)
                {
                    throw RecordException.Enrich(ex, oldNpc);
                }
            }

            // Creatures
            foreach (var oldCreature in state.LoadOrder.PriorityOrder.WinningOverrides<ICreatureGetter>())
            {
                try
                {
                    if (oldCreature.Data?.Health == null || oldCreature.EditorID == null)
                        continue;

                    var newCreature = oldCreature.DeepCopy();

                    if (newCreature.Data?.Health == null || newCreature.Data.Health <= 1)
                        continue;

                    newCreature.Data.Health = CalcHealth(newCreature.Data.Health);

                    state.PatchMod.Creatures.Set(newCreature);
                    Console.WriteLine(
                        $"Successfully modified creature. EditorID:{oldCreature.EditorID} Name:{oldCreature.Name}");
                    ++count;
                    Console.WriteLine($"\tOldHealth:{oldCreature.Data.Health} NewHealth:{newCreature.Data.Health}\n");
                }
                catch (Exception ex)
                {
                    throw RecordException.Enrich(ex, oldCreature);
                }
            }

            // Weapons
            foreach (var oldWeapon in state.LoadOrder.PriorityOrder.WinningOverrides<IWeaponGetter>())
            {
                try
                {
                    if (oldWeapon.Data == null || oldWeapon.EditorID == null)
                        continue;

                    var newWeapon = oldWeapon.DeepCopy();

                    if (newWeapon.Data?.Damage == null || newWeapon.Data.Type == Weapon.WeaponType.Bow ||
                        newWeapon.Data.Type == Weapon.WeaponType.Staff)
                        continue;

                    newWeapon.Data.Damage =
                        (ushort)(newWeapon.Data.Damage * Settings.MeleeDmgMult + Settings.MeleeDmgBonus);

                    state.PatchMod.Weapons.Set(newWeapon);
                    Console.WriteLine($"Successfully modified weapon: {oldWeapon.EditorID}");
                    ++count;
                    Console.WriteLine(
                        $"\tOldDmg:{oldWeapon.Data.Damage} NewDmg:{newWeapon.Data.Damage} Type:{oldWeapon.Data.Type}\n");
                }
                catch (Exception ex)
                {
                    throw RecordException.Enrich(ex, oldWeapon);
                }
            }

            Console.WriteLine($"For reference..\n");
            Console.WriteLine($"calcHealth(10):{CalcHealth(10)}\n");
            Console.WriteLine($"calcHealth(75):{CalcHealth(45)}\n");
            Console.WriteLine($"calcHealth(100):{CalcHealth(100)}\n");
            Console.WriteLine($"calcHealth(1000):{CalcHealth(1000)}\n");

            Console.WriteLine($"\nFinished patching {count} records.\n");
        }

        private static uint CalcHealth(uint health)
        {
            var x = SqueezeFormula(health, Settings.HealthMinGuess, Settings.HealthMaxGuess, Settings.HealthMinTarget, Settings.HealthMaxTarget);
            return (uint)Math.Max(1, x.ToInt());
        }

        private static float SqueezeFormula(float x, float minGuess, float maxGuess, float minTarget, float maxTarget)
        {
            return Math.Max(0, (x - minGuess) / (maxGuess - minGuess)) * (maxTarget - minTarget) + minTarget;
        }
    }
}